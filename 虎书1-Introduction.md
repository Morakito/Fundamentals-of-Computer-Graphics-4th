---
title: 虎书笔记——Chapter1：Introduction
tags:
  - 图形学
categories:
  - 图形学
date: 2022-04-21 10:01:45
---

# 引言

计算机图形学这个术语描述了任何使用计算机创建和操作图像的行为。这本书介绍了很多算法和数学工具，它们可以用来创建各种类型的图象——逼真的视觉特效、信息丰富的技术插图和漂亮的计算机动画。图形可以是2D的或者3D的，图像可以是完全合成的，也可以是通过对照片进行操纵生成的。这本书包含了计算机图形学中的基础算法和数学方法，尤其是使用三维模型和场景来生成图象的那部分。

实际上，从事计算机图形学的研究不可避免的需要了解特定的硬件、文件格式和图形API（通常是一种或者两种）。计算机图形学是一个快速发展的领域，其中的知识和技术细节是在不断的变化。因此在这本书中，我们尽可能的不依赖特定的硬件或者API。我们鼓励读者通过阅读相关的文档来了解软硬件环境。幸运的是，计算机图形学的文化中有着足够标准的术语和概念，本书中的相关讨论应该能够很好的应用到大部分环境中。

本章节定义了一些基本的术语和它们的历史背景，以及与计算机图形学相关的信息来源。

## 1.1 图形领域

在任何领域强行分类都是很危险的，但是大部分图形从业者都认同以下几个计算机图形学的主要应用领域：

- **建模**：建模针对形状和外观属性定义了一种能够存储在计算机上的数学规范。例如：一个咖啡杯能够被描述为一组有序的、3D空间中的点和一些用来连接这些点的插值规则，以及一个用来描述光如何和杯子相互作用的反射模型。
- **渲染**：渲染是一个从艺术继承过来的概念，它负责从3D的计算机模型创建出已着色的图象。
- **动画**：动画是一种通过一系列图象来创造运动错觉的技术。动画使用了建模和渲染的技术，但是增加了随着时间运动的关键问题，这一点通常不会在基本的建模和渲染中处理。

还有很多其他领域涉及了计算机图形学，它们是否是图形学的核心领域主要是观点问题。它们都会在本文中被提及。这些相关领域包括：

- **用户交互**用于处理不同输入设备的接口，例如鼠标和平板电脑、应用程序、图象形式的反馈以及其他感觉反馈。从历史上看，该领域和图形学相关联很大程度上是因为图形研究者最早接触到了输入输出设备，虽然现在这些设备现在随处可见。
- **虚拟现实**试图让用户沉浸在3D虚拟世界中。通常来说，它至少需要立体图形头部运动反馈两项技术。对于真正的虚拟现实而言，它应该同样支持声音和力反馈。因为这一领域需要先进的3D图形技术和先进的显示技术，它通常和图形学关系密切。
- **可视化**试图通过视觉展示，使得用户能够了解更加复杂的信息。在可视化问题中通常需要解决一些图形问题。
- 图象处理：它包含了对2D图象的一系列操作，被应用于图形学和计算机视觉两个领域。
- **3D扫描**运用测距技术来创建3D扫描模型。这些模型对于创建丰富的视觉图像很有用，处理这些模型通常需要图形学算法。
- **计算摄影**利用计算机图形学，计算机视觉和图像处理等方法，使用全新的方式来逼真地捕捉物体，场景和环境。

## 1.2 主要应用

几乎所有的努力都可以利用计算机图形学，但是计算机图形学技术最主要的消费者集中于以下行业：

- **电子游戏**越来越多的使用到了精致的3D模型和复杂的渲染算法。
- **卡通片**通常直接从3D模型渲染获得。很多传统的2D动画会使用3D模型来渲染背景，这可以使得视角进行连续的移动，节省大量艺术家的时间和工作量。
- **视觉特效**使用了几乎各种类型的计算机图形学技术。几乎所有的现代电影都会使用数字合成技术将背景和单独拍摄的前景进行叠加。很多电影也会使用3D建模和动画技术来创建虚拟环境，物体，甚至是大多数观众从来不会怀疑其真实性的角色。
- **动画电影**使用了很多和视觉特效一样的技术，但是动画电影的目标不一定看起来真实的图像。
- **CAD/CAM**代表了计算机辅助设计和计算机辅助制造。这些领域使用计算机技术在电脑上设计零件和产品，然后使用这些虚拟的设计来指导制造过程。例如：很多机械零件使用了3D计算机建模包来进行设计建模，然后在一个计算机控制的铣削设备上自动生产。
- **模拟**可以被认为是精确的电子游戏。例如：一个飞行模拟器使用复杂精细的3D图形来模拟驾驶飞机的体验。在驾驶等具有危险性的领域中，这些模拟对于它们的初始训练非常有用；或者对经验丰富的用户进行情景培训，例如现实中过于昂贵或危险的特定消防状况。
- **医学成像**可以为扫描的患者数据创建有意义的图像。例如：计算机断层扫描（CT）数据集由包含密度数据的大型3D矩形阵列组成。通过使用计算机图形学来合成图像，能够帮助医生从大量的数据中提取出最重要的信息。
- **信息可视化**从那些没有一个“自然”的视觉表现的数据中创建图像。例如：一段时间内的十只股票价格趋势没有显著的视觉表现，但是聪明的图形技术能够帮助人们了解这些数据中的规律。

## 1.3 图形API

使用图形库的一个关键部分是处理图形API。应用程序接口（API）是执行一组相关操作的函数的标准集合，图形API是一组执行基本操作的函数集合，例如在屏幕窗口上绘制图像和3D表面。
任何图像程序都需要使用两个相关的API：一个用于可视化输出的图形API和一个用于获取用户输入的用户界面API。目前图形API和用户界面API主要有两种范例。第一种是类似Java的综合方法，它的图形和用户界面部分通过一种集成的，可移植的方式整合在语言中，这些库是标准化的并且作为语言的一部分得到支持。第二种的代表是Direct3D和OpenGL，其中的绘制命令作为软件库的一部分和其他语言绑定（比如C++）；而用户界面部分则是相对一个独立的实体，可能会因系统而异。在第二种方法中，对于简单的程序来说，可以使用可移植的库来封装特定系统的用户界面代码，但是编写可移植、跨平台的代码仍然可能会出现一些问题，
无论你选择哪一种API，基本的图形调用大体上是一样的，本书中的概念也是适用的。

## 1.4 图形管线

今天每一个桌面计算机都拥有一个强大的图形管线。这是一个用于在透视视角高效绘制3D图元的特殊软硬件子系统。通常这些系统会为了处理具有共享顶点的3D三角形而进行优化。渲染管线中最基本的操作是将3D顶点映射到屏幕上的2D位置，并且对这些三角形进行着色，使得它们看起来都很真实，同时以正确的前后顺序出现。
虽然如何使用有效的前后顺序来绘制三角形曾经是计算机图形学中最重要的研究内容，但是现在几乎都使用Z-缓冲来解决这个问题，它使用一个特殊的内存缓冲区来以暴力的方式解决这个问题。
事实证明，图形管线中所用到的几何操作几乎都可以在四维坐标空间中完成，它包含三个传统的几何坐标和第四个用于帮助处理透视观察的齐次坐标。这些4D坐标使用4X4的矩阵和4维向量来操作。因此图形管线中包含了很多用于高效处理和组合这些矩阵向量的机制。这个四维坐标系统是计算机科学中最微妙和美丽的结构之一，这无疑也是在学习计算机图形学的过程中需要克服的最大的思维障碍。每一本图形学书籍的第一部分都会有很大一部分内容是在处理这些坐标。
图像生成的速度很大程度上取决于被绘制的三角形数量。对于很多应用程序来说，交互性比画面质量更加重要，因此尽可能的减少用于表现模型的三角形数量是值得的。除此之外，如果一个模型在很远的地方被观察到，那么它应该使用比在近处观察更少的三角形。
这表明，使用不同的细节级别来表现一个模型是很有用的。

## 1.5 数值问题

很多图形程序实际上只是3D数值代码，对于这些程序而言，数值问题通常是至关重要的。在过去，以一种健壮、可移植的方式来处理这些数值问题是非常困难的，因为不同的机器有着不同的数字内部表示，更糟糕的是，它们甚至连处理异常的方式都是不同且不兼容的。幸运的是，几乎所有的现代计算机都遵守IEEE浮点标准（IEEE标准协会，1985年）。这允许程序员对如何处理某些数值条件做出许多方便的假设。
尽管IEEE浮点在编码数值算法的时候具有很多有价值的特性，但是对于图形学中遇到的大部分情况，只有少数特性是至关重要的。首先，也是最重要的，需要理解在IEEE浮点数中有三个特殊的实数值。

1. 无穷（$\infty$）：这是一个有效的数字，且比其他所有的有效数字都要大。
2. 负无穷（-$\infty$）：这是一个有效的数字，且比其他所有的有效数字都要小。
3. 不是数字（NaN）：这是一个产生于具有未定义结果的操作的无效数字，例如0除以0。

IEEE浮点数的设计者做了对于程序员非常方便的决定。其中很多跟上面三个处理异常（如除以0）的特殊值有有关。在这些情况下会记录一个异常，但是在许多情况下，程序员可以忽略它。特别地，对于任意正实数$a$而言，会遵守以下有关于无穷值除法地规则

$$
+a/(+ \infty )=+0 \\[1mm]
-a/(+ \infty )=-0 \\[1mm]
+a/(- \infty )=-0 \\[1mm]
-a/(- \infty )=+0 \\[1mm]
$$

> IEEE浮点数中的0有两种表现形式，一个被视为正，一个被视为负。-0和+0的区别只是在部分情况下会产生影响，但是这一点差异值得被记住。

其他涉及无穷值的操作是符合人们预期的，同样的对于任意正实数$a$而言，其行为如下：

$$
\infty + \infty = \infty, \\[1mm]
\infty - \infty = \infty, \\[1mm]
\infty \times \infty = \infty, \\[1mm]
\infty / \infty = NaN, \\[1mm]
\infty / a = \infty, \\[1mm]
\infty / 0 = \infty,\\[1mm]
0 + 0 = NaN. \\[1mm]
$$

对于涉及无穷值得布尔表达式，其预期如下：

1. 所有的有限数字都比 $+\infty$小
2. 所有的有限数字都不$-\infty$大
3. $-\infty$小于$+\infty$

对于表达式中含有NaN值得规则如下：

1. 所有包含NaN的算数表达式结果都为NaN
2. 所有包含NaN的布尔表达式结果都是false

也行IEEE浮点数最有用的方面就是如何处理被0除，对于任意正实数$a$而言，在涉及被0除的时候需要遵守以下规则：

$$
+a / +0 = + \infty \\
-a / +0 = - \infty
$$

> 当-0出现的时候，需要额外当心

如果程序员利用好IEEE规则，那么有许多数值计算将会变得简单许多。例如，考虑以下表达式：

$$
a = \frac{1}{\frac{1}{b} + \frac{1}{c}}
$$

这样的表达式常出现在电阻器和透镜中。如果出现了除0的情况，会导致程序会发生崩溃（就像在IEEE浮点数出现之前的很多系统一样），为了避免这种情况的发生，这时候需要两个if语句来判断b和c是否是0值或者极小值。而在IEEE浮点数中，如果b和c是0，那么计算得出的a也是0。另一个用于避免特殊值检查的常见技术是利用NaN的布尔属性。考虑以下代码块：

```text
a = f(x)
if(a > 0) then
  do something
```

在上面的代码中，函数f（x）可能会返回一些“丑陋”的值比如$\infty$或者NaN，但是if条件仍然运行良好：当$a = NaN$或者$a=-\infty$的时候返回false，当$a = +\infty$的时候返回true。在决定返回那些值的时候，if通常会做出正确的决定而不需要做特殊的检查，这使得程序更加小巧、健壮、有效。

## 1.6 效率

对于如何使得代码变得更有效这方面，没有什么魔法准则。效率是通过谨慎的权衡获得的，这些权衡对于不同的体系结构中是不同的。但是对于可预计的未来，一个很好的启发是：程序员更需要关注内存访问模式而不是操作计数。这和20年前的最佳启发刚好是相反的，这种情况出现的原因是因为内存的速度没有跟上处理器的速度。由于这一趋势仍在持续，因此有限的和连续的内存访问对于优化的重要性只会增加。
一种使得代码运行更快的合理方法是按照以下准则进行处理，只采取那些需要的步骤即可：

1. 使用最直接的方式来写代码。计算机在计算过程中只需要知道中间结果即可，而不是花费额外的算力来存储它。
2. 使用优化模式来编译你的代码。
3. 使用任何存在的分析工具来找到关键的性能瓶颈。
4. 检查你的数据结构，寻找改善局部性的方法。如果可能的话，使得数据单元的大小和目标体系结构的缓存/页面大小相匹配。
5. 如果性能分析显示瓶颈在数值计算上，检查由编译器生成的汇编代码是否缺少效率，重写源代码来解决你发现的任何问题。

在这些步骤中，最重要的是第一个。大部分“优化”并不会加速运行效率，反而会使得可读性变差。另外，将时间花费在预先的代码优化上通常要比花在修复bug和添加特性上好。除此之外，要注意来自旧文本的建议；一些经典的优化技巧如使用整数代替实数可能不会再产生速度，因为现代CPU执行浮点运算的速度和执行整数运算的速度一样快。在任何的情况下，都需要使用性能分析来衡量对特定机器和编译器所进行的优化是否有价值。

## 1.7 设计和编码图形程序

一些常见的策略对于图形编程来说也很有用，在本小节中，我们将提供一些建议，当你在尝试实现在本书中学习到的一些算法时可能会有所帮助。

### 1.7.1 类设计

任何图形程序的一个关键部分是对于几何实体具有良好的类和例程（计算机子程序的别称），例如向量和矩阵，以及图形实体例如RGB颜色和图像。这些例程应该尽可能地整洁和高效。一个普遍地设计问题是位置和位移是否应该是不同地类，因为它们具有不同地行为和操作。例如：一个位置乘以0.5没有任何几何意义，然而一个位移乘以0.5却有着明确地几何意义。在这个问题上，人们几乎没有达成一致地建议，这可能会在图形从业者中引发数小时地激烈辩论，但是为了举个例子，我们假设我们将不对位置和位移做区分。
> 我坚信KISS准则（Keep It Simple，Stupid），在这个观点下，将它们分成两个类的观点不足以证明增加复杂性是合理的。 —— P.S.
> 我喜欢分离点和向量的做法，因为这增强了代码的可读性，同时可以让编译器捕获一些bug。—— S.M.

这意味着要编写以下类在内的基本类：

- vector2：一个存储了x，y两个分量的二维向量类。它应该将这些分量存储在一个长度为2的数组中以支持索引运算符。你还需要添加包括加法、减法、点积、叉积、标量乘法和标量除法在内的向量运算。
- vector3：一个类似于vector2的三维向量类。
- hvector：一个具有四分分量的齐次向量。
- rgb：一个拥有三个分量的RGB颜色类。你还需要添加包括RGB加法、RGB减法、RGB乘法、标量乘法和标量除法在内的运算。
- transform：一个拥有变换的4X4矩阵。你还需要添加矩阵乘法和成员函数来应用位置，方向和表面法向量。详见第六章，这些运算都是不同的。
- image：一个具有输出操作的，由RGB像素组成的2D数组。

> 你可能会考虑为单位向量提供一个特殊的类，尽管我发现它们所带来的痛苦大于带来的价值。 —— P.S.

另外，你可能或者可能不想为间隔、标准正交基地和坐标系添加类。

### 1.7.2 单精度 vs 双精度

现代计算机体系结构建议：减少内存使用和保持内存连续访问是保证效率的关键。这告诉我们需要使用单精度数据。但是为了避免数值问题，建议使用双精度算法。这些权衡取决于程序功能，但是最好是在类定义中有个默认的设置。

> 我建议使用双精度浮点进行几何运算，使用单精度浮点进行颜色计算。建议使用单精度浮点来存储数据，例如三角形网格，因为这些数据会占据大量内存，但是建议在成员函数访问这些数据的时候将其转换为双精度浮点。 —— P.S.
> 我主张在任何计算中都使用单精度浮点，除非你发现了在特定部分必须要使用双精度浮点的证据 —— S.M.

### 1.7.3 调试图形程序

如果你四处打听，你会发现越有经验的程序员，他们使用传统调试器的次数就会越少。其中的一个原因是，使用这样的调试器对复杂程序进行调试，会比调试简单程序笨拙的多。另一个原因最困难的错误往往都是概念错误，即错误的事情正在被执行。很容易浪费大量的时间来逐个检查变量值而忽略这样的错误。我们发现了几种在图形学中特别实用的调试策略。

#### 科学方法

在图形程序中，有一种通常非常有用的，替代传统调试的方法。它的缺点是，它和计算机程序员职业生涯早期被教导不要做的事情非常类似，当你使用这种方法的时候可能会感觉自己很“淘气”：我们创建一张图像，然后观察它哪里出现了错误。然后我们提出一个可能导致错误发生的假设并尝试修复它。举个例子：在一个光线追踪的程序中，我们可能会获得很多看起来有点随机的暗像素，这是一个叫做“阴影粉刺”的经典问题，很多人在写光线追踪程序的时候都会遇到。传统调试方法在这里是没什么用的，相反我们必须意识到，这是因为阴影光线投射在了被遮蔽的表面。我们可以观察到那些暗点的颜色其实是环境的颜色，即缺失了直接光照。由于直接光照在阴影中不起作用，所以你可能会做出这样的假设：这些点被错误标记了，其实它们并没有在阴影中。为了测试这个假设，我们可以尝试关闭阴影检查然后重新编译，这将表明那些阴影测试都是错误的，然后我们可以继续进行我们的侦探工作。这个方法有时很有用的关键原因是因为我们从来没有发现一个错误的值或者真正确定了我们的概念性错误，相反的是，我们通过不断地假设测试，用实验地方式缩小了概念错误的范围。通常只需要几次实验我们就可以追踪到错误的情况了，这种调试方式是令人愉快的。

#### 使用图像作为编码调试的输出

在很多情况下，在图形程序中获取调试信息最简单的方式就是输出图像本身。如果你想知道一个参与每个像素计算过程的变量的值是多少，你可以暂时地修改程序，将该变量的值直接复制到输出图像中，并跳过剩下的计算。例如：如果你怀疑是表面法线导致产生了了阴影的问题，你可以直接将法向量复制到输出图像中（法向量的xyz分量分别对应颜色的rgb分量），这样你的程序就会输出一个向量的颜色编码图片。又或者你怀疑某个变量有时会越界，那么让你的程序在这种情况发生的地方输出明亮的红色。其他常见的技巧包括使用明显的颜色来绘制表面的背面（当它们不应该可见的时候），使用物体的ID来为图像着色，又或者根据像素计算所需的工作量来为其着色。

#### 使用调试器

当然还有这样的情况，尤其是当科学方法看起来会导致矛盾的时候，或者是没有什么能用来代替观察到底发生了什么情况的时候。图形程序中通常包含了很多相同代码的重复执行（例如逐像素，逐三角形），这导致了在调试器中从程序入口逐步执行的调试方法是完全不可行的。而且通常最困难的bug往往只会在某些复杂输入中出现。
一个处理bug的实用方法是“设置一个陷阱”。首先，确保你的程序是确定性的——将其运行在一个单独的线程上，并且保证所有的随机数都使用了固定的随机种子。
> 一种使用固定随机种子的特殊调试模式是很有用的。
>
然后找出产生bug的像素或者三角形，并在你怀疑可能出问题的代码前添加一条语句，该语句只对可疑情况执行。例如：你发现像素（126，247）出现了bug，然后添加：

```text
if x = 126 and y = 247 then
  print "blarg!"
```

如果你在输出语句前打了一个断点，那么就能在计算你关注的像素前进入调试器。有些调试器有一个叫做“条件断点”的特性，它能够在不修改代码的情况下完成相同的事情。
在程序崩溃的情况下，传统调试器对于定位崩溃是很有用的。然后你应该在程序中进行回溯，使用断言和重新编译来找出程序发生的错误。这些断言应该被保留，以备调试将来添加的潜在错误。这意味着避免了传统的逐步调试过程，因为传统的调试方法将不会给程序添加有价值的断言。

#### 可视化调试数据

通常来说要理解你的程序在做些什么是很困难的，因为它在出现问题之前计算了大量的中间数据。这种情况和处理大量数据的科学实验有点类似，并且有一个方法是通用的：使用图形和图表来帮助你理解数据的含义。例如：在一个光线追踪程序中，你可以编写代码来可视化一颗射线树，这样你就能看到那些路径对这个像素产生了贡献；或者在一个图像重采样例程中，你可以通过绘制图形，来显示从输入图像中获取的所有采样点。花费时间来为你的程序编写内部状态可视化代码，这样你在尝试优化它的时候也能获得更好的理解。

> 我喜欢格式化的调试输出语句，以便于输出恰好是Matlab或者Gnuplot脚本，它们能绘制很有用的图表。

## 备注

有关软件工程的讨论受到了*Effective C++ series*系列 (Meyers, 1995, 1997)，*Extreme Programming*（Beck & Andres，2004）和 *The Practice of Programming*（Kernighan&Pike, 1999）的影响。有关实验性调试的讨论是基于Steve Parker的讨论。
还有很多和图形学相关的年度会议，包括ACM SIGGRAPH和SIGGRAPH Asia, Graphics Interface, the Game Developers Conference (GDC), Eurographics, Pacific Graphics, High Performance Graphics, the Eurographics Symposium on Rendering和IEEE VisWeek。这些会议可以通过在网页上搜索它们的名称快速找到。
