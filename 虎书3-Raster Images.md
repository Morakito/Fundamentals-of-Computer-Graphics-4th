---
title: 虎书笔记——Raster Image
tags:
  - 图形学
  - 虎书
categories:
  - 图形学
date: 2022-04-21 10:01:45
---

# 光栅化图像

大部分计算机图形学图像是在某种*光栅显示器*上呈现给用户的。光栅显示器将图像显示成像素的矩形阵列。一个常见的例子是平板电脑显示器和电视机，他们有一个微小的发光像素的矩形阵列，这些像素可以被单独设置成不同的颜色来创建任何想要的图片。通过将不同强度的红、绿、蓝光混合在一起，从而可以组合出不同的颜色。大多数的打印机，比如激光打印机和喷墨打印机，也属于光栅设备的一种。它们都是基于扫描技术的。虽然在物理上是不存在实际的像素方格，可以通过在按顺序网格的选定点上沉积墨水来创建图像。
> 像素Pixel：是“图像元素（picture element）”的缩写。

光栅化也流行于图像的输入设备。数码相机中有一个图像传感器，传感器上面有一组感光像素的网格，每个感光像素都可以记录下照射到它上面的光的颜色和强度。桌面扫描仪包含了一组直线排列的像素阵列，它会逐行扫描整个页面，每秒进行多次测量，生成一个像素网格。
> 打印机中的颜色更加复杂，它涉及了至少四种颜料的混合。

由于光栅化在设备中非常流行，因此光栅化图像也是存储和处理图像最常用的一种方式。一个光栅化图像只是一个二维数组，它存储了每个像素的像素值——通常是颜色的三个分量即红、绿、蓝。通过使用存储图像的每个像素来控制显示器上像素的颜色，我们就可以将一个光栅化图像显示在显示器上。
> 或者也可能是光栅化图像太方便了，因此这些设备也都是光栅化的。

但是我们并不总是希望用这种方式来显式图像，我们希望能够改变图像的大小和朝向，修正它的颜色，或者是将其显示在一个移动的三维表面。即使是在电视机中，显示器和被显示的图像很少会有完全相同的像素数量。像这样的思考和想法打破了图像像素和显示器像素的直接联系。因此最好是将光栅化图像看做成一种*设备无关*的图像描述方法，将显示设备看成一种理想图像的近似方法。
除了使用像素整列，还要一些其他用于描述图像的方法。*矢量图像*是通过定义形状来描述的，即以线或曲线包围成的颜色区域，而不是参考任何的像素网格。从本质上来看，它实际存储了用于显示图像的指令，而不是显示图像所需的像素。矢量图像最大的好处是它是与分辨率无关的，它可以被显示在高分辨率设备上。相应的，它的缺点就是在被显示之前需要进行额外的光栅化。矢量图像通常用于文字，图表，机械图纸等以及其他需要高清晰度和高精度的场景，这类场景一般不需要逼真的图像或者复杂的引用。
在本章中，我们会讨论光栅化图像和显示器的基本概念，尤其会关注标准显示设备的非线性。有关像素值和光强之间的关系细节是很重要的，当我们在后续章节中讨论有关计算图像的话题时，你需要对它有个印象。
> 换而言之：你需要知道图像中的这些数字的实际含义。

## 3.1 光栅化设备

在讨论抽象的光栅化图像之前，先了解一下这些设备对图片的基本操作是很有帮助的。一些常见的光栅化设备可以被分成如下简单的结构：

- 输出
  - 显示
    - 透光的：液晶显示器（LCD）
    - 自发光的：发光二极管显示器（LED）
  - 屏幕拷贝
    - 二值的：喷墨打印机
    - 连续色调：热升华打印机
- 输入
  - 二维阵列传感器：数码相机
  - 一维阵列传感器：平板扫描仪

### 3.1.1 显示器

包括电视机，数字电影放映机，还有电脑显示器和投影仪在内的现代显示器，几乎都是基于固定的像素阵列。它们可以被分为自发光式显示器和透射式显示器：前者使用直接发光的像素来控制光线数量；后者像素本身不发光，但是它们可以调整允许通过光线的数量。透射式显示器需要额外的光源来将其照亮：在一个可以直接观察的显示器上，这个光源是在像素阵列背后的*背光*；在一个投影仪中，它是一种在通过阵列之后发光的灯，并将光投影到屏幕上。对于一个自发光显示器而言，它依靠自己像素本身发光。
![图3.1](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205031408433.png)
> **图3.1**：发光二极管显示器的工作原理。

发光二极管（LED）显示器是自发光显示器的一种，每个像素由一个或者多个LED构成。LED是一种半导体设备（基于无机或者有机半导体），它可以根据自身通过的电流强度发出不同强度的光线（图3.1）。
![图3.2](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205031417629.png)
> **图3.2**：一个平面显示器包含很多像素，每个像素由红、绿、蓝子像素构成。

彩色显示器上的像素被分成三个独立控制的*子像素*——颜色分别为红绿蓝，每个子像素的LED都使用了不同的材料，因此它们可以发出不同颜色的光线（图3.2）。当从远处观察LED显示器的时候，人的眼睛是无法分辨出这些独立的子像素的，人们能观察到的是红绿蓝光线混合之后的颜色。
![图3.3](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205031421097.png)
> **图3.3**：图片下方是一个处于关闭状态的LCD显示器像素，它的前偏振片阻拦了所有通过后偏振片的光线。图片上方是一个处于开启状态的LCD显示器像素，它的液晶单元旋转了光的偏振性，因此光可以通过前偏振片。该图片由Erik Reinhard提供。

液晶（LCD）显示器是一种透射式的显示器。液晶是一种特殊材料，它的分子结构可以旋转通过它的偏振光，旋转的角度大小可以通过所施加的电压大小来进行调节。一个LCD像素（图3.3）的背后有一层偏振片，因此像素可以被偏振光照亮。这里我们假设偏振片是水平方向的。
![图3.4](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205031441815.png)
> **图3.4**：液晶显示器（LCD）的工作原理。

像素前的第二层偏振片被设定成了只能允许垂直极化的光通过。如果施加的电压使得中间的液晶层并没有改变光的偏振性，那么所有的光线都会被阻挡，此时像素处于“关闭”状态（最小强度）。如果施加的电压使得中间的液晶层将光的偏振性旋转了90度，那么所有通过后偏振片的光都会从前偏振片中穿过，此时像素处于完全“开启”状态（最大强度）。中间状态的电压会部分改变光的偏振角度，产生介于最小强度和最大强度之间的光（图3.4）。和LED显示器一样，彩色LCD显示器的像素也有红、绿、蓝颜色的子像素，每个独立子像素上都有红、绿、蓝不同颜色的滤镜。
包括上述和其他显示技术在内，任何具有固定像素网格的显示器，都有一个由网格大小决定的基础固定分辨率。对于显示器和图像而言，分辨率意味着像素网格的维度：如果一个桌面显示器的像素分辨率是$1920 \times 1200$，这意味它有1920列，1200行，总计230400个像素。
一个拥有不同分辨率的图片，如果要填满整个显示器，它的分辨率必须被转换成$1920 \times 1200$，这个技术将在第9章中讨论。
> 显示器的分辨率有时候也被称作“原生分辨率”，因为大部分显示器都可以通过内置的转换来处理其他分辨率的图片。

### 3.1.2 硬拷贝设备

> 注：这里的硬拷贝(Hardcopy)应该是相对于软拷贝(Softcoy)而言的，指的是将电子文档影印出来。

将图像永久地记录在纸上和将其短暂地显示在显示器上是完全不同的。颜料或者其他反光介质被有序的分布在纸上从而构成想要的图像。打印机和显示器一样都是光栅化设备，但是很多打印机只能打印*二值化图像*：在一个网格位置上，只存在有颜料或者没有颜料两种状态，没有其他可能的中间状态。
![图3.5](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205031524515.png)
> 喷墨打印机的工作原理。

喷墨打印机（图3.5）是就是这样的一种设备，它通过扫描来构成一个光栅化图像。喷墨打印机的打印头上有也太油墨载体颜料，它能够在电子控制下每次喷出很小的一滴墨水。打印头在纸上移动，在需要接收墨水的位置上喷出墨滴，在需要留白的地方不释放墨滴。在每次扫描之后，纸张会向前移动一点点，使得下一行移动到打印头下方。彩色打印需要使用几个不同的打印头，每个打印头会喷出不同的颜料，因此每个每个位置上都可以接收到不同颜色墨滴的组合。由于喷墨打印机的所有墨滴都是一样的，因此它只能打印二值化图像：在每个位置上只有喷墨和不喷墨两种状态，没有其他中间状态。
> 还有一些连续喷墨打印机，纸张被包裹在滚筒表面，它以连续的螺旋路径打印而不是来回移动头部。

喷墨打印机没有物理的像素阵列，因此其分辨率取决于喷出的墨滴尺寸和一次扫描后纸张向前移动的距离。很多打印机的打印头上都有多个喷嘴，它可以使得打印机在一次扫描中进行多行打印，但是最后是纸张移动的距离决定了每行的间距，而不是喷嘴的喷嘴的间距。
![图3.6](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205031605575.png)
> **图3.6**：热升华打印机的工作原理。

热升华打印机（图3.6）是连续色调打印的一个例子，它意味着在每个像素上可以沉积不同数量的液滴，这和喷墨打印机完全不同。一个包含彩色颜料的*色带*被压在纸张之间，*打印头*由一组线性阵列的加热元件构成，它对应图像中的一行像素。当纸张和色带通过打印头的时候，打印头上的加热元件会切换开关状态来加热指定色带上指定区域的颜料，使得颜料升华从色带转移到纸张上。这个过程会对几种颜色的颜料（CMYK）重复进行。由于更高的加热温度可以使得更多的颜料被转移，因此落在每个位置上的颜料数量是可以被控制的，这允许产生一个连续的颜色范围。打印头上的加热元件数量决定了横向（穿过页面的方向）的固定分辨率，但是纵向（沿着纸张方向）的分辨率是由加热冷却速度还有纸张移动速度决定的。
和显示器不一样，打印机的分辨率是用*像素密度*而不是像素总数定义的。如果一个热升华打印机的打印头上有300个加热元件，那么其页面横向分辨率就是300ppi（pixels per inch），如果纵向分辨率和横向一样，那么我们可以称这个打印机的分辨率就是300ppi。对于一台每英寸可以放置1200个点的喷墨打印机，我们可以称其分辨率为1200dpi（dots per inch）。
> 术语“dpi”常用于描述每英寸像素数量（pixel per inch），但是dpi应该被用于二值化设备，ppi应该被用于连续色调设备。

喷墨打印机是一种二值化设备，它需要更精细的打印网格，即更高的dpi，这至少有两个原因。第一个原因是，由于喷墨打印机打印出的图像都是黑白边界，更高的分辨率可以避免锯齿和走样的出现（章节8.3）。当使用喷墨打印机来打印连续色调的图片时，需要使用更高的分辨率，通过打印被称为*半色调*的不同密度的点阵来模拟中间颜色。

### 3.1.3 输入设备

光栅化图像一定来自于某个地方，如果不是通过算法计算出来的，那么一定是通过某些*光栅化输入设备*测量产生的，最常见的就是相机和扫描仪。即使是在渲染3D场景的时候，这些照片也经常被用作纹理贴图（章节11）。一个光栅化输入设备需要对每个像素进行光线测量，这通常也是基于传感器阵列实现的（类似于输出设备）。
![图3.7](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205041538304.png)
> **图片3.7**：数码相机的工作原理。

数码相机是二维阵列输入设备的一种，相机中有一个图像传感器，这是一种由光敏像素网格构成的半导体设备。两种常见的图像传感器阵列分别是CCD（电荷耦合元件）和CMOS（互补金属氧化物半导体）。相机的镜头将要拍摄的场景图像投影到传感器上，然后每个像素分别测量落在它上面的光能，最终生成一个输出图像的像素值（图3.7）。
![图3.8](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205041546588.png)
> **图3.8**：大多数彩色数码相机中的颜色滤镜阵列类似于图片中的*拜耳马赛克*。每个像素分别测量红、绿、蓝光。

和色彩显示器中使用的红绿蓝子像素很像，大部分彩色相机使用颜色滤镜阵列或者马赛克，使得每个感光像素只能看见红绿蓝单色光，然后让图像处理软件来填充在去*马赛克(demosaicking)*过程中缺失的值（图3.8）。
其他的相机使用三个独立的阵列，或者阵列中三个不同的层，来分别测量红、绿、蓝光，无需进一步的处理即可获得可用的图像。相机的分辨率由阵列中的固定像素数量决定，通常表示为像素的总数：一个具有3000列和2000行阵列的相机可以拍摄出一张分辨率为$3000 \times 2000$的图像，即6百万像素的图片，这样的相机被称作6MP(megapixel)相机。需要注意的是，马赛克传感器并不能记录一副完整的彩色图像，因此使用相同像素但是红绿蓝光单独测量的相机，能够比马赛克相机记录更多的图像信息。
> 买相机的人所说的“兆”指的是$10^6$，而不是兆字节中的$2^20$。

![图3.9](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205041642933.png)
> **图3.9**：平面扫描仪的工作原理。

平面扫描仪也会测量网格中每个像素的红绿蓝值，但是和热升华打印机类似，它使用一个一维阵列来扫描整个纸张，在一秒内会进行多次测量。它的横向分辨率由一维阵列的固定尺寸决定，竖向分辨率与扫描频率还有扫描头移动速度有关。彩色扫描仪的阵列尺寸为$3 \times n_x$，其中的$n_x$是横向像素的数量，每行像素被红绿蓝色的滤镜所覆盖。在测量三种颜色时会有一个合适的时间间隔，这保证了在一个网格点上进行三次独立的颜色测量。和连续色调打印机类似，扫描仪分辨率的单位也是ppi(pixels per inch)。
> 扫描仪的分辨率有时候被叫做“光学分辨率”，因为大多数的扫描仪可以通过内置转换来生成其他分辨率的图像。

我们已经知道了图像从哪里来和图像要去做什么的具体信息，现在我们将要更加抽象地讨论图像，就像我们在图形算法中使用它们一样。

## 3.2 图像，像素和几何

我们知道光栅化图像其实是一个巨大的图像阵列，每个像素存储了图像上该点的颜色信息。我们已经看到了各种各样的输出设备是如何处理图像的，还有各种各样的输入设备如何在现实世界中从由光构成的图像中获得它们。但是对于计算机中的计算，我们需要一种方便的、独立于任何特定设备的抽象概念，用来描述如何生成图像，或者如何解析存储在图像中的值。
当我们测量或者重现图像的时候，我们采取了光能二维分布的形式：从显示器上发出的光，是一个与其在显示器表面上位置有关的函数；落在相机图像传感器上的光，是一个与其在传感器上位置有关的函数；反射系数，或者是光反射的比例（相对于光被吸收的比例），是一个跟在纸张上位置有关的函数。
> “像素并不是一个很小的正方向！” ——Alvy Ray Smith, 1995

所以在现实世界里面，图像也是定义在二维区域上的函数——这些二维区域几乎都是长方形。因此我们可以将图像抽象成一个如下的函数：
$$
I(x, y):R \to V,
$$
其中的$W \subset \mathbb{R}^2$是一个长方形区域，$V$是可能的像素值的集合。最简单的例子是理想的灰度图像，长方形区域中的每个点只有一个亮度属性（没有颜色），我们可以认为$V = \mathbb{R}^+$。对于理想的彩色图像，每个像素分别记录了红绿蓝分量，即$V = (\mathbb{R}^+)^3$。我们将在下一节讨论$V$的其他可能性。
> 是否存在不是长方形的光栅化设备?

如何将光栅图像与连续图像的抽象概念联系起来？让我们看一看具体的例子，相机或者扫描仪的一个像素，测量了图像上某个像素周围微小区域的平均颜色。一个包含红绿蓝子像素的显示器像素，其平均颜色由光栅图像上对应的像素值所控制。在上面的两个例子中，像素值是图像的局部平均颜色，它被称为图像的*采样点(point sample)*。换而言之，当一个像素点的值为$x$，它意味着“在该点附近的图象值为$x$。”图像作为函数采样表示的想法将在第9章中进一步讨论。
![图3.10](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205050949869.png)
> **图3.10**：一个4像素$\times$3像素屏幕的坐标系、请注意，在某些API中，y轴正方向会指向下。

像素在二维空间中的位置是一个简单但是很重要的问题。虽然这仅仅是一个约定的事情，但是建立一个始终如一的约定是非常重要的。在本书中，光栅化图像上坐标为(i, j)的像素代表了从左下角开始的第$i$列，第j$行的像素。如果一个图像有$n_x$列，$n_y$行，那么左下角的像素坐标为$(0, 0)$，右上角的像素坐标为$(n_x - 1, n_y - 1)$。我们需要一个二维实数屏幕坐标系来指定这些像素位置，我们将把像素的采样点放在整数坐标上，如图3.10所示的大小为$4 \times 3$的屏幕。
> 在一些图形API和文件格式中，图像的行是从上往下排列的，即(0, 0)点在左上角。这是一个历史遗留问题：以前的电视机的行是从上往下排列的。

图像的长方形定义域长$n_x$，宽$n_y$，且每个采样点都位于网格的中心，这意味着最两侧的采样点会向外延申半个像素。因此尺寸为$n_x \times n_y$的图像定义域为：
$$
R = [-0.5, n_x - 0.5] \times [-0.5, n_y - 0.5]
$$
再次提醒一下，这些坐标仅仅是一个约定，但是它们是很重要的，尤其是后面再实现相机和视角变换的时候。
> 有些系统将坐标系整体偏移半个像素，使得采样点再整数中间，而图像的边缘位于整数坐标上。

### 3.2.1 像素值

到目前为止，我们已经用实数描述了像素值，在图像上的一点表示颜色强度（可能分别用红绿蓝三个分量表示）。这表明了图像应该被表示成一个浮点数阵列，每个像素可能会使用一个（*灰度图*或者黑白图片），或者三个（RGB彩色图片）32位浮点数来存储颜色。这个格式会在需要精度和范围的场景下使用，但是由于一张图片中有很多像素，因此用于存储、传输图像的内存和带宽很可能会不够。使用这种格式，一张一千万像素的图片可能会消耗115MB的存储空间。
> 为什么是115MB而不是120MB？一千万像素一共需要$1.2\times 10^8$个字节，1MB相当于$2^10 \times 2^10$个字节

对于哪些需要直接展示的图片，它只需要很小的范围就可以了。理论上光强的范围是无限的，但是任何设备都会有一个有限的最大强度。而且对于像素来说，一个有限的范围也是完全足够的，通常为了简化，会将像素值限制在$[0, 1]$中。举个例子，对于一个8bit图像而言，像素的取值范围是$0, 1/255, 2/255, \ldots, 254/255, 1$。
> 有点尴尬地是这里的分母是255而不是256，但是能够正确表示0和1是很重要地。

使用浮点数来存储的图像，其像素值范围很大，这被叫做*HDR(high dynamic range)*；使用整数存储的图像，像素值范围固定，这被叫做LDR(low dynamic range)。在章节21中会对HDR技术和应用有更深入的讨论。
以下是一些应用程序中常见的像素格式：

- 1-bit 灰度——文本和其他不需要中间灰色的图像（可能需要高分辨率）。
- 8-bit RGB 固定范围颜色（24bit/像素）——网页和邮件应用程序，消费级照片。
- 8-bit或10-bit 固定范围RGB（24-30bit/像素）：电脑显示器的数字接口。
- 12-14-bit 固定范围RGB（36-42bit/像素）：为专业摄影提供的原始相机图像。
- 16-bit固定范围RGB（48bit/像素）：用于专业摄影和印刷；处理其他固定范围图像的中间格式。
- 16-bit “半精度”浮点RGB——HDR图像，实时渲染的中间格式。
- 32-bit浮点RGB——用于软件渲染和处理HDR图像的通用中间格式。

减少图像中每个像素使用的比特数会导致两种类型的*瑕疵（artifact）*，或者叫做人为引入的缺陷。第一种，在编码使用固定范围像素值的图像时，超出最大亮度值的的像素值可能会被裁剪或者限制到最大亮度。例如，一张拍摄阳光常见的照片种可能会有一些比白色表面还要明亮的反射，当转换为用于显示图像的固定范围格式时，这些过亮的区域会被裁剪（即使它们是通过相机拍摄的）。第二种，当编码低精度的图像时，会出现因像素值“四舍五入”到离散数值而造成的颜色或者强度的跳跃变化，这会导致伪影或者色带的产生（摩尔纹）。这种条状色带在静态图像中可能不是特别令人反感，但是在动画和视频中，尤其是当画面前后移动的时候，这种伪影会变得很明显。

### 3.2.2 显示器强度和伽马值

所有的现代显示器将像素值作为数字输入，然后将其转换成一个强度水平。现实中的显示器在关闭的时候也有一些非零的强度值，因为屏幕本身也会反射一些光线。出于我们的目的，我们将这种情况设定为“黑色”，将显示器的最大强度设定为“白色”。我们假设像素颜色的数值范围是0到1，黑色为0，白色为1，介于黑白中间的灰色是0.5。注意这里说的“中间”是指从像素中发出的光线的物理数量，而不是具体的表现。因为人类对光强的感知是非线性的，这不是本章节的讨论内容，我们将在第20章讨论这个问题。
想要在屏幕上正确显示图片，必须要先理解两个关键问题。首先，显示器的输出相对于它的输入是非线性的，例如：如果你将0，0.5，1.0作为显示器上三个像素的输入值，那么显示器的强度水平将表现为0，0.25，1.0（分别对应完全关闭，四分之一打开和完全打开）。显示器通常将$\gamma$("gamma")作为对非线性的一种近似描述，这个值就是下列公式中的自由度（指数？）：
$$
\mathrm{displayed \  intensity} = \mathrm{(maximum \ intensity)} \alpha ^ \gamma \tag{3.1}
$$
其中的$\alpha$代表输入的介于0到1之间的像素值。例如：如果一个显示器的伽马值为2.0，然后我们输入了一个像素值$a = 0.5$，那么显示器的强度水平会是最大强度的四分之一，因为$0.5^2 = 0.25$。请注意，无论伽马值是多少，显示器强度在$a = 0$的时候都是0，在$a = 1$的时候都是1。我们只是使用$\gamma$来近似描述显示器的非线性，因此在估计显示器$\gamma$的时候不用特别精确。通过找到一个$a$值来使得屏幕强度水平位于黑白中间是一个衡量非线性的很好的视觉方法，其中的$a$是：
$$0.5 = a^\gamma $$
如果我们能够找到这样一个的$a$，那么我们就能够在等式两边取对数来推导出$\gamma$:
$$
\gamma = \frac{\ln 0.5}{\ln a}
$$
我们可以通过一个标准技术找到这样的一个$a$，将一个包含黑白像素块的棋盘格放置在一个像素值为$a$的灰色像素块旁边（图3.11），然后让用户来调整（例如通过一个滑动条）$a$的值，直到左右两侧的平均亮度一致。
![图3.11](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205051547211.png)
> **图3.11**：从远处看，黑白相间的像素块的亮度是黑白的一半。可以通过找到一个和黑白相间的像素块亮度一致的灰色值从而推断出显示器的伽马值。

当你从远处看这幅图片的时候（如果你近视的话，可以直接摘下眼镜看），若像素值为$a$的灰色的亮度为黑白的一半，那么图片两侧看起来大概会是一样的。因为模糊的棋盘格将很多个黑色和白色的像素混合在了一起，整体效果就是一个介于黑白之间的均匀颜色。
当我们知道了显示器的伽马值之后，我们就可以对输入的像素值进行*伽马校正*，即$a = 0.5$的像素强度会是黑色和白色的一半。这可以通过如下变换完成：
$$a^\prime = a^ \frac{1}{\gamma}$$
将上述公式带入方程(3.1)，我们可以获得：
$$\begin{aligned}
\mathrm{displayed \  intensity} &= (a^\prime)^\gamma = (a^ \frac{1}{\gamma})^\gamma \mathrm{(maximum \ intensity)}\\
&=a\mathrm{(maximum \ intensity)}
\end{aligned}$$
> 对于有模拟接口的显示器，沿水平方向剧烈改变其强度是很困难的，水平方向的黑白条纹比颜色相间的棋盘格效果要好。

现实中的显示器还有另一个重要的特点，那就是它们接收量子化的输入数据。虽然我们可以在$[0, 1]$的浮点范围内控制强度变化，但是对于显示器而言，输入的是一个固定长度的整数。最常用的整数范围是0-255，因为这刚好可以用一个字节8bit来进行存储。这意味着$a$不是$[0, 1]$中的任意数值，而是：
$$\mathrm{possible\ values\ for}\ a = \left\{\frac{0}{255}, \frac{1}{255}, \frac{2}{255}, \cdots, \frac{254}{255}, \frac{255}{255}\right\}
$$
这意味着可能显示的强度近似值为：
$$\left\{M\left(\frac{0}{255}\right)^\gamma, M\left(\frac{1}{255}\right)^\gamma, M\left(\frac{2}{255}\right)^\gamma, \cdots, M\left(\frac{254}{255}\right)^\gamma, M\left(\frac{255}{255}\right)^\gamma\right\}$$
其中的$M$是显示器的最大强度，在一些需要控制精确强度的应用中，我们必须实际测量256中可能的强度，这些强度值可能在屏幕的不同点上是不同的，尤其是对于CRT（阴极射线管）显示器而言。它也可以会随着视角的变化而变化，但是幸运的是，很少有应用程序需要如此精确的校准。

## 3.3 RGB颜色

大部分计算机图像都是使用RGB颜色定义的。RGB颜色是一个简单的颜色空间，它允许直接将其转换到计算机屏幕上。在本小节中，我们将从用户的角度来讨论RGB颜色，目标是操作方便。RGB颜色空间技术已经允许我们编写大部分的图形程序，有关更深入的颜色话题将在第19章讨论。RGB颜色空间的基本想法是通过混合三种光（红绿蓝）来显示颜色，光以*加色混合*的方式混合在一起。
> 在小学的时候，你可能学习过红黄蓝是三原色，并且黄色+蓝色=绿色。这是一种*减色混合*的方法，它和显示器中的加色混合有根本性的不同。

![图3.12](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205051717710.png)
> **图3.12**：红绿蓝颜色的加色混合原则。

在RGB中进行加色混合（图3.12），我们可以得到：
$$
\mathrm{red + green = yellow,}\\
\mathrm{green + blue = cyan,}\\
\mathrm{blue + red = magenta,}\\
\mathrm{red + green + blue = white.}
$$
“青色”也可以叫做蓝绿色，“洋红色”也可以叫做紫红色。
如果我们可以将原色光从完全关闭（像素值为0）调整到完全打开（像素值为1），那么我们就能构建出所有可以显示在RGB显示器上的颜色。红绿蓝像素值可以构成一个以红绿蓝三色为轴的三维RGB颜色立方体。坐标轴的允许范围是0到1，颜色立方体如图3.13所示。
![图3.13](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205051727763.png)
> **图3.13**：RGB颜色立方体和表面展开的结果，任何RGB颜色都是立方体中的一个点。

立方体上8个角的颜色值分别是：
$$
\mathrm{black = (0, 0, 0),}\\[1mm]
\mathrm{red = (1, 0, 0),}\\[1mm]
\mathrm{green = (0, 1, 0),}\\[1mm]
\mathrm{blue = (0, 0, 1),}\\[1mm]
\mathrm{yellow = (1, 1, 0),}\\[1mm]
\mathrm{magenta = (1, 0, 1),}\\[1mm]
\mathrm{cyan = (0, 1, 1),}\\[1mm]
\mathrm{white = (1, 1, 1).}
$$
实际的RGB颜色值是以量化形式给出的，类似于我们在章节3.2.2中讨论的灰度，每个分量都表示成一个整数。最常用的格式是用一个字节来表示一个整数，即RGB颜色的三个分量都是0-255的整数。三个整数一共是三个字节，即24bit。因此一个具有“24位颜色”的系统对于三原色都有256中可能的级别。章节3.2.2中讨论的伽马校正也可以单独运用于RGB颜色的每个分量。

## 3.4 透明度混合

有时候我们只想要覆盖一部分像素的内容，一个常见的例子就是*混合*，例如我们有一个背景图片，现在想在它上面插入一个前景图片。对于前景图片中不透明的像素，我们可以直接覆盖替换掉背景图片上对应的像素；对于前景图片中完全透明的像素，我们可以直接忽略，不对背景图片上相应的像素进行改变；而对于前景图片中部分透明的像素，我们必须格外的注意。当前景物体有部分透明的区域时，例如玻璃，在图像中会出现部分透明的像素。最常见的前景图片和背景图片必须混合的例子是前景物体只覆盖了部分像素，即在前景物体的边缘，或者出现了亚像素级别的孔洞如一棵遥远的树的树叶之间。
将前景物体混合在背景物体上所需要的最重要的信息是*像素覆盖范围*，它告诉我们前景图层所覆盖像素的比例，我们可以把这个比例记作$\alpha$。如果我们将一个前景色$\mathbf{c}_f$和背景色$\mathbf{c}_b$相混合，前景覆盖的像素比例为$\alpha$，我们可以使用如下公式来进行混合：
$$\mathbf{c} = \alpha \mathbf{c}_f + (1 - \alpha)\mathbf{c}_b \tag{3.2} $$
对于一个不透明的前景图层，其解释是前景物体战区了像素长方形内的区域$\alpha$，背景物体占据了剩余的区域，即$(1 - \alpha)$。对于一个透明的前景层（想象一张使用半透明油漆的，画在玻璃或者透写纸上的画），其解释是穿过背景层的光线，被前景层遮住了$1 - \alpha$，同时前景层自身的颜色贡献了$\alpha$，使用方程(3.2)进行混合的图片如图3.14。
> 由于前景图层和背景图层的权重之和为1，所以当前景背景颜色相同的时候，最后组合出的结果和之前是一样的。

![图3.14](https://morakito-blog.oss-cn-beijing.aliyuncs.com/Fundamentals-of-Computer-Graphics-4th/Chapter-3/202205061352515.png)
> **图3.14**：使用方程(3.2)进行合成的一个例子。前景图像在被叠加到背景图像上面之前，实际上是被$\alpha$通道裁剪出来的。最下面的图片是组合的结果。

一个图像中全部的$\alpha$值可能会存储在一个单独的灰度图像中，它通常叫做$\alpha$*遮罩*或者*透明遮罩*。或者是将这个信息存储在RGB图像中的第四个通道，通常叫做$\alpha$*通道*，这样的图片通常被叫做RGBA图片。对于一个8bit的图像，每个像素占据32bit大小，这在很多计算机体系结构中都是一个易于处理的长度。尽管方程(3.2)被广泛应用，但是在不同的情况下，$\alpha$的用法也是不同的(Porter & Duff, 1984)。

### 3.4.1 图像存储

大部分RGB图像格式使用8bit来存储每个通道（红绿蓝）的像素值。也就是说，对于一个包含1百万像素的图片，大概包含3百万字节的原生信息。为了减少存储需求，大部分图像格式都会进行一些压缩。从宏观来看（at a high level），图像格式可以分为*无损压缩*和*有损压缩*。在无损压缩中，图片不会丢失任何信息；而在有损压缩中，一些丢失的信息是无法恢复的。常见的图像存储格式如下：

- **jpeg**：这是一种有损压缩格式，它根据人类视觉系统来对像素块进行压缩，它非常适用于自然图像。
- **tiff**：这种图像最常用于保存二进制图像和无损压缩的8bit或16bit的RGB图像，尽管还有一些其他选项。
- **ppm**：这是一种简单的无损的、未压缩的格式，通常用于保存8bitRGB图像，尽管还有一些其他选项。
- **png**：这是一种无损压缩的图像格式，它有很多好用的开源管理工具。

由于各种压缩算法和变体，因此可能会涉及到编写图像的输入输出例程。很幸运的是我们可以使用一些第三方库来对标准图像格式进行读写操作。对于快速且粗略(quick-and-dirty)的应用程序，简洁比效率更有价值，因此使用原生的ppm格式来进行图像的读写。它可以通过为内存中的像素数组添加适当的文件头来将其存储为一个文件。

## 常见问答

**为什么不将显示器直接设置成线性的从而避免伽马校正的问题？**
在理想情况下，显示器中256个可能的强度应该看起来均匀间隔，而不是线性能量间隔。这是因为人类对于强度的感知本身就是非线性的。介于1.5-3的伽马值（取决于观察条件）可以使得强度在主观感受上大致均匀。也就是说伽马是一个不可避免地特性，否则的话各大厂商会直接将显示器制造成线性地。
